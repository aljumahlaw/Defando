# القرارات التقنية والمعمارية
## Technical and Architectural Decisions

**التاريخ:** 2025  
**الإصدار:** 1.0  
**الحالة:** ✅ **معتمد**

---

## 1. مقدمة

هذا المستند يوثّق **القرارات التقنية والمعمارية الأساسية** في مشروع **LegalDocSystem**:

- يوضّح **لماذا** تم اختيار كل تقنية أو تصميم.
- يساعد على **توحيد الفهم** بين أعضاء الفريق.
- يسهّل **مراجعة القرارات مستقبلًا** عند التفكير في التوسع أو إعادة التصميم.
- يشكّل مرجعًا لأي **تغييرات معمارية مدروسة** (Architectural Evolution).

> **ملاحظة:**  
> ملف **`GETTING_STARTED_AND_STRUCTURE.md`** يركّز على “كيف أبدأ؟” و “كيف يبدو هيكل المشروع؟”  
> بينما هذا الملف يركّز على **لماذا** اخترنا هذه التقنيات وهذه البنية.

---

## 2. جدول القرارات الرئيسية (Decision Table)

الجدول التالي يلخص أبرز القرارات التقنية، مع الأسباب والبدائل والتأثير:

| # | القرار (Decision) | السبب (Rationale) | البدائل المرفوضة (Rejected Alternatives) | التأثير (Impact) |
|---|--------------------|--------------------|-------------------------------------------|-------------------|
| 1 | **Backend: ASP.NET Core 8 (C#)** | إطار حديث مدعوم طويل الأمد، أداء عالي، تكامل ممتاز مع الهوية وSignalR، ودعم EF Core وHangfire. | Node.js/Express, Laravel/PHP, Java/Spring | أداء جيد، تكامل قوي مع بيئة Windows، سهولة التوظيف لمطوري .NET، دعم طويل الأمد. |
| 2 | **Frontend: Blazor Server** | يقلل تعقيد الواجهة (لا حاجة لـ SPA منفصل)، يسمح بإعادة استخدام C#، والأمن أعلى لأن المنطق على الخادم. | React, Angular, Vue (SPA منفصل) | تقليل تعقيد البنية (مشروع واحد بدل اثنين)، صيانة أسهل، سرعة تسليم أعلى، لكن مع اعتماد أكبر على اتصال مستمر (SignalR). |
| 3 | **Database: PostgreSQL 14+** | ميزات متقدمة (JSONB, Full-Text Search, GIN indexes)، مستقر ومفتوح المصدر. | SQL Server, MySQL, Oracle | مرونة في البحث، تكلفة أقل (OSS)، أداء جيد مع أحمال معاملاتية وتحليلية، استقلالية عن تراخيص مغلقة. |
| 4 | **Password Hashing: BCrypt (BCrypt.Net-Next)** | خوارزمية معتمدة، بطيئة عن قصد، مقاومة لـ brute-force، سهلة الاستخدام في .NET. | SHA-256/512, PBKDF2, Argon2 (لم يُعتمد في الإصدار الحالي) | أمان كلمات المرور مرتفع، قابلية تكوين Work Factor، تكامل سهل مع كود C#. |
| 5 | **Data Encryption: DPAPI/AES** | DPAPI للاستفادة من حماية النظام في Windows، وAES للأنظمة الأخرى؛ مناسب للبيانات السرية مثل كلمات مرور SMTP. | تخزين كلمات المرور كنص عادي، Base64 فقط، تشفير مخصص غير موثّق | رفع مستوى أمان البيانات الحساسة، تقليل خطر التسريب عند اختراق قاعدة البيانات أو ملفات الإعداد. |
| 6 | **OCR: Tesseract OCR 5.x** | مجاني، يدعم العربية والإنجليزية، يعمل محليًا دون خدمات سحابية. | Azure Cognitive Services, Google Vision, AWS Textract | عدم الاعتماد على سحابة خارجية (متطلبات قانونية/خصوصية)، تكلفة أقل، إمكانية تشغيل بدون اتصال دائم بالإنترنت. |
| 7 | **PDF: iText7** | مكتبة ناضجة لإنشاء/تعديل PDF في .NET، مع دعم واسع للميزات. | PDFSharp, Syncfusion, مكتبات مدفوعة أخرى | مرونة عالية في التعامل مع PDF، توافق جيد مع .NET، توازن بين الميزات/التكلفة. |
| 8 | **Email: MailKit** | مكتبة خفيفة وآمنة للتعامل مع SMTP، مدعومة جيدًا في .NET. | System.Net.SmtpClient (قديمة)، مزودو SDK سحابي فقط | تحكم كامل في الاتصال بالبريد، دعم بروتوكولات حديثة، أداء أفضل من SmtpClient. |
| 9 | **Background Jobs: Hangfire + PostgreSQL Storage** | جدولة موثوقة وخدمات Retry داخل نفس التطبيق، تخزين في PostgreSQL. | Windows Task Scheduler, Cron + خدمات منفصلة, Azure Functions | تقليل البنية الخارجية المطلوبة، سهولة المراقبة من Dashboard مدمجة، موثوقية أعلى في معالجة المهام المؤجلة. |
| 10 | **Audit Logging داخلي** | تتبع كل العمليات الحساسة داخل النظام (Login, CRUD, Lockout, إلخ). | الاعتماد على Logs عامة فقط (Application logs) | قدرة على تحقيق/تحليل أدق للأحداث، دعم متطلبات الامتثال، تحسين مراقبة السلوكيات غير الاعتيادية. |
| 11 | **Blazor Server في الإصدار الأول بدل WebAssembly** | تسليم أسرع، تعقيد أقل، سهولة Debug، لا حاجة لتوزيع Frontend ثابت على CDN في المرحلة الأولى. | Blazor WebAssembly, SPA منفصل | تقليل زمن الإطلاق، وتركيز الجهد على المنطق والأمان بدلاً من البنية المعقدة. |

> أي قرار إضافي ذُكر في المستندات الأصلية (مثل توصيات أو خيارات تم استبعادها مبكرًا) يُعتبر إما:
> - موثّقًا هنا، أو
> - منقولًا إلى قسم “القرارات المفتوحة أو القابلة للمراجعة” أو “الملحق”.

---

## 3. نظرة على الطبقات المعمارية (Architecture Overview)

الهدف من هذا القسم هو توثيق **منطق التقسيم الطبقي** في المشروع، وليس مجرد تكرار هيكل المجلدات.

### 3.1 طبقة واجهة المستخدم (UI – Blazor Server)

- **القرار:** استخدام Blazor Server لواجهة المستخدم.
- **المنطق:**
  - واجهات تفاعلية غنية باستخدام C# وRazor Components.
  - إدارة الحالة في الخادم، مما يسهل حماية المنطق والأسرار (لا يتم إرسال معظم الكود للعميل).
- **التأثير:**
  - تبسيط البنية (Mono-Repo، مشروع .NET واحد).
  - يحتاج اتصالاً ثابتًا نسبيًا بين العميل والخادم (SignalR)، مما يجب أخذه في الحسبان عند النشر.

### 3.2 طبقة الخدمات (Services Layer)

- **القرار:** فصل المنطق التطبيقي في طبقة Services مستقلة عن UI وDbContext.
- **الأسباب:**
  - تسهيل اختبار المنطق (Unit Tests) دون UI.
  - تحسين قابلية إعادة الاستخدام (نفس الخدمة يمكن استدعاؤها من Blazor Components أو من API Controllers).
- **التوزيع:**
  - واجهات مثل `IDocumentService`, `IFolderService`, `ITaskService`, `IUserService`.
  - تنفيذات مثل `DocumentService`, `FolderService`, `TaskService`, `UserService`.
- **التأثير:**
  - تحسين قابلية الصيانة.
  - تمكين DI وMocking بسهولة في الاختبارات.

### 3.3 طبقة البيانات (EF Core + PostgreSQL)

- **القرار:** استخدام Entity Framework Core مع PostgreSQL.
- **الأسباب:**
  - إنتاجية أعلى للمطورين (LINQ، Tracking، Migrations/Schema Scripts).
  - توافق ممتاز مع ASP.NET Core.
- **التصميم:**
  - `ApplicationDbContext` هو نقطة الدخول للبيانات.
  - 14 كيان (Entity) تعكس الجداول الأساسية (Users, Documents, Folders, AuditLog, …).
  - استخدام Fluent API في `OnModelCreating` لضبط العلاقات والقيود.
- **التأثير:**
  - تسريع التطوير، على حساب قدر من التحكم اليدوي في SQL (وهو مقبول في هذا السيناريو).

### 3.4 طبقة الأمان (Security Layer – Cross-cutting)

- **القرار:** عدم إنشاء طبقة “أمان” منفصلة بالكامل، بل تطبيق الأمان كـ **Cross-Cutting Concern**:
  - Authentication & Authorization مدمجة في البنية (Program.cs, Middleware, Attributes).
  - Encryption & Audit Logging على مستوى الخدمات والبيانات.
- **التأثير:**
  - الأمان مدمج في مسار التنفيذ الطبيعي، وليس “مكونًا جانبيًا” فقط.
  - الحاجة إلى توثيق واضح (تم إنجازه في مجلد `01-Security/`).

---

## 4. قرارات الأمان (Security Decisions)

هذا القسم يلخص القرارات الأمنية الرئيسية، مع روابط للمستندات التفصيلية.

### 4.1 المصادقة والتفويض (Authentication & Authorization)

- **القرار:**
  - استخدام **Cookie Authentication** مع Claims وRoles.
- **السبب:**
  - متوافق مع ASP.NET Core.
  - بسيط ومناسب لتطبيق داخلي (On-Premises).
- **التأثير:**
  - جلسات آمنة تعتمد على Cookies، مع دعم Role-based Authorization في Blazor وControllers.
- **تفاصيل إضافية:**
  - راجع: `docs/01-Security/AUTHENTICATION_AND_AUTHORIZATION.md`.

### 4.2 حماية CSRF (Cross-Site Request Forgery)

- **القرار:**
  - تفعيل Anti-Forgery Tokens في REST API Controllers عبر:
    - `AddAntiforgery` + `UseAntiforgery`.
    - `[ValidateAntiForgeryToken]` على جميع Actions الحساسة (POST/PUT/DELETE/PATCH).
- **السبب:**
  - اتّباع أفضل ممارسات ASP.NET Core لمنع هجمات CSRF.
- **التأثير:**
  - طلبات التعديل تحتاج Token صحيح؛ يقلل من خطر تنفيذ أوامر غير مصرح بها بالنيابة عن المستخدم.
- **تفاصيل إضافية:**
  - راجع: أقسام CSRF في `SECURE_CONFIGURATION_AND_INFRASTRUCTURE.md` و `AUTHENTICATION_AND_AUTHORIZATION.md`.

### 4.3 سياسات الكوكيز وHSTS

- **القرارات:**
  - **Cookie SecurePolicy** = `Always` في الإنتاج (HTTPS فقط).
  - **SameSite = Lax** لمعظم الكوكيز.
  - تفعيل **HSTS** في الإنتاج مع:
    - `MaxAge` طويل (365 يومًا).
    - `IncludeSubDomains = true`.
    - `Preload = true` (عند تسجيل النطاق في قائمة HSTS preload الرسمية).
- **السبب:**
  - ضمان مرور جميع الاتصالات عبر HTTPS.
  - تقليل هجمات Cookie Theft وMan-in-the-middle.
- **التأثير:**
  - فرض استخدام HTTPS بشكل صارم على المتصفحات التي تدعم HSTS.

### 4.4 Rate Limiting وAccount Lockout

- **القرارات:**
  - تنظيم Rate Limiting على:
    - المستخدمين المصادق عليهم (AuthenticatedUserPolicy).
    - Endpoint تسجيل الدخول (LoginPolicy).
    - حد عام لكل IP (GlobalLimiter).
  - تطبيق **Account Lockout** بعد عدد معين من المحاولات الفاشلة (قابلة للتخصيص).
- **السبب:**
  - تقليل تأثير هجمات Brute-force.
- **التأثير:**
  - حماية حسابات المستخدمين وموارد النظام من المحاولات المتكررة.

### 4.5 Encryption Service (DPAPI/AES + Key Management)

- **القرار:**
  - استخدام DPAPI على Windows وAES على بيئات أخرى، مع إدارة المفاتيح عبر:
    - Configuration (`Encryption:Key`).
    - أو متغير بيئة `LEGALDOC_ENCRYPTION_KEY`.
- **السبب:**
  - عدم الاعتماد على مفاتيح مشتقة من MachineName أو قيم يمكن تخمينها بسهولة.
- **التأثير:**
  - خط دفاع إضافي ضد تسريب أسرار التطبيق (مثل كلمات مرور SMTP).

> التفاصيل الدقيقة لهذه القرارات موجودة في:  
> `docs/01-Security/DATA_PROTECTION_AND_ENCRYPTION.md` و  
> `docs/01-Security/SECURE_CONFIGURATION_AND_INFRASTRUCTURE.md`.

---

## 5. قرارات البنية التحتية والتكوين (Configuration & Infrastructure)

### 5.1 User Secrets في التطوير

- **القرار:**
  - استخدام **User Secrets** في بيئة التطوير لتخزين البيانات الحساسة (كلمات مرور DB، مفاتيح التشفير).
- **السبب:**
  - عدم إدراج الأسرار في Git.
- **التأثير:**
  - فصل الكود عن القيم السرية، تحسين الأمان في بيئات التطوير.

### 5.2 Environment Variables في الإنتاج

- **القرار:**
  - استخدام متغيرات البيئة في الإنتاج (مثل `LEGALDOC_DB_PASSWORD`, `LEGALDOC_ENCRYPTION_KEY`).
- **السبب:**
  - اتّباع أفضل الممارسات في نشر التطبيقات (12-Factor App Style).
- **التأثير:**
  - سهولة إدارة الأسرار عبر منصات الاستضافة (Windows Services, IIS, Docker, Kubernetes…).

### 5.3 فصل appsettings.* لكل بيئة

- **القرار:**
  - استخدام:
    - `appsettings.json` للإعدادات العامة.
    - `appsettings.Development.json` للتطوير.
    - `appsettings.Production.json` للإنتاج (عند الحاجة).
- **التأثير:**
  - مرونة أكبر في ضبط الإعدادات حسب البيئة، وتقليل أخطاء النقل بين البيئات.

### 5.4 إدارة Connection Strings وكلمات المرور

- **القرار:**
  - ترك Connection String في `appsettings.json` بدون كلمة مرور حقيقية (`Password=;` أو Placeholder).
  - إدخال كلمة المرور من User Secrets/Env Variables عند التشغيل (في `Program.cs`).
- **السبب:**
  - منع تسريب بيانات الاتصال حتى لو تم تسريب `appsettings.json`.
- **التأثير:**
  - يحتاج المطور إلى إعداد الأسرار قبل تشغيل المشروع، لكن الأمان أعلى.

### 5.5 Logs وAudit

- **القرارات:**
  - تسجيل Logs قياسية عبر ASP.NET Core Logging.
  - تخزين Audit Logs في جدول مخصص (مثل `audit_log`) مع:
    - Sanitization للبيانات الحساسة قبل الحفظ.
- **التأثير:**
  - إمكانية التحقيق في سلوك النظام والأخطاء بشكل دقيق.
  - تقليل خطر تسريب أسرار عبر السجلات.

---

## 6. متطلبات بيئة المطوّر (Developer Environment Expectations)

هذه الفقرة تلخّص ما يجب أن تتوافر عليه **بيئة المطوّر القياسية**، استنادًا إلى `DECISIONS.md`.

### 6.1 مكونات البيئة القياسية

- **نظام تشغيل مدعوم:** Windows 10/11 أو Server 2019+.
- **SDK:** .NET 8 SDK.
- **IDE:** Visual Studio 2022 أو VS Code (مع إضافات C#).
- **قاعدة بيانات:** PostgreSQL 14+ مع صلاحية إنشاء قواعد بيانات وتطبيق السكربتات.
- **أدوات مساعدة:**
  - Git.
  - Tesseract OCR (في حال اختبار OCR محليًا).
  - حساب SMTP للاختبار (يمكن أن يكون حسابًا داخليًا).

### 6.2 توقعات من المطوّر

- القدرة على:
  - تشغيل `dotnet restore`, `dotnet run`, وربما `dotnet ef database update`.
  - تعديل `appsettings.Development.json` بما يناسب بيئته المحلية.
  - إعداد User Secrets وEnv Vars حسب التوثيق.

---

## 7. قرارات مفتوحة أو قابلة للمراجعة (Open / Revisitable Decisions)

بعض القرارات قد تُراجع في المستقبل مع توسّع المشروع:

1. **إمكانية الانتقال إلى Blazor WebAssembly أو Frontend منفصل:**
   - **الحالة:** مؤجل.
   - **التفكير:** قد يكون منطقيًا عند الحاجة لتوسيع قابلية التوسع الأفقي، أو تحسين تجربة المستخدم في بيئات ذات اتصال غير مستقر.
2. **دعم قواعد بيانات إضافية (مثل SQL Server أو MySQL):**
   - **الحالة:** قيد الدراسة طويلة الأمد.
   - **السبب:** متطلبات عملاء محتملين أو سياسات بنية تحتية داخلية.
3. **الانتقال إلى مزود خدمة سحابي لـ OCR أو البحث (ElasticSearch/Cloud OCR):**
   - **الحالة:** مؤجل.
   - **السبب:** يعتمد على متطلبات أداء متقدمة أو تكامل مع أنظمة أخرى.

> أي تغيير فعلي في هذه القرارات يجب أن يوثّق في إصدار جديد من هذا الملف مع تحديث قسم “تاريخ التعديلات”.

---

## 8. تاريخ التعديلات (Decision History)

| الإصدار | التاريخ | الوصف | المسؤول |
|--------|---------|--------|---------|
| 1.0 | 2025 | إنشاء المستند وتجميع جميع القرارات من `DECISIONS.md` والوثائق ذات الصلة في ملف موحّد. | فريق التطوير الأساسي |

> عند إجراء أي تغييرات مستقبلية (مثل تغيير قاعدة البيانات، أو اعتماد Frontend منفصل)، يتم:
> - تحديث هذا الجدول.
> - تحديث الأقسام ذات الصلة بالقرار.

---

## 9. ملحق (Appendix)

أي تفاصيل أو ملاحظات تقنية لم تُستخدم مباشرة في الأقسام السابقة، وتمت الإشارة إليها في الوثائق القديمة، يمكن تلخيصها هنا، مثل:

- ملاحظات حول أدوات استُخدمت في المراحل المبكرة ثم تم استبدالها.
- تجارب أداء (Benchmarks) غير نهائية.
- أفكار تصميمية تم رفضها بعد تجارب أولية.

حاليًا، جميع القرارات المهمة التي كانت في `DECISIONS.md` تم استيعابها في الأقسام السابقة، ويمكن توسيع هذا الملحق عند الحاجة مستقبلاً.

---

**آخر تحديث:** 21 نوفمبر 2025  
**الحالة:** ✅ القرارات التقنية والمعمارية موثّقة وجاهزة للمراجعة المستمرة



